# Калькулятор матриц Николаева ИС-323 ✅
---

- **package main**
<br> oбъявление основного пакета программы

**import (
<br>"fmt"
<br>)**
- импорт необходимых компонента Go:
fmt - ввод/вывод
---
**func main() {**
- точка входа в программу, выводит меню операций и обрабатывает выбор пользователя
---
**fmt.Println("Выберите операцию:")**
- вывести заголовок меню
---
**fmt.Println("1. Сложение матрица")**
- вывод пункта меню — сложение
---
**fmt.Println("2. Вычитание матрица")**
- вывод пункта меню — вычитание
---
**fmt.Println("3. Умножение матрицы на скаляр")**
- вывод пункта меню — умножение на число
---
**fmt.Println("4. Умножение двух матриц")**
- вывод пункта меню — умножение матриц
---
**var userChoice int**
- объявление переменной для хранения выбора пользователя
---
**fmt.Print("Ваш выбор: ")**
- приглашение к вводу номера операции
---
**fmt.Scan(&userChoice)**
- считывание целого числа — выбор пользователя
---
**switch userChoice {**
- разветвление по выбранной операции
---
**case 1:**
- если выбрано сложение
---
**executeMatrixOperation(addMatrices, "сложения")**
- вызов общей функции с операцией сложения
---
**case 2:**
- если выбрано вычитание
---
**executeMatrixOperation(subtractMatrices, "вычитания")**
- вызов функции с операцией вычитания
---
**case 3:**
- если выбрано умножение на скалярную величину
---
**MultipleByScalar()**
- вызывает функцию умножения матрицы на число
---
**case 4:**
- если выбрано умножение матрицы
---
**MultipleMatrices()**
- вызывает функцию матричного умножения
---
**default:
		fmt.Println("Неверный ввод. Пожалуйста, выберите число от 1 до 4.")**
- если введено недопустимое значение, то выведется сообщение об ошибке
**func readMatrix(label string) [][]float64 {**
- функция для ввода матрицы от пользователя
---
**var rows, cols int**
- объявление приложения для чисел, строк и столбцов
---
**if label != "" {**
- если метка задана, выводим её в запросе (например, "матрицы A"), иначе — общий запрос
---
**fmt.Printf("Введите размерность матрицы %s (строки столбцы): ", label)**
- запрос размерности с именем 
---
} else {
**fmt.Print("Введите размерность матрицы (строки столбцы): ")**
- иначе запрос размерности без имени
---
**fmt.Scan(&rows, &cols)**
- считывание количества строк и столбцов
---
**matrix := make([][]float64, rows)**
- цикл по индексу строк: от 0 до rows
---
**fmt.Println("Введите элементы матрицы построчно (через пробел):")**
- ❗важная подсказка: ввод через пробел
---
**for i := 0; i < rows; i++ {**
- цикл по строкам
---
**matrix[i] = make([]float64, cols)**
- для текущей строки i выделяем память под cols чисел
---
**for j := 0; j < cols; j++ {**
- цикл по столбцам
---
**fmt.Scan(&matrix[i][j])**
- считывание каждого элемента матрицы по одному
---
**func printMatrix(matrix [][]float64) {**
- функция вывода матрицы
---
**for _, row := range matrix  {**
- перебор строки матрицы
---
**for _, val := range row {**
- перебор элементов в строке
---
**fmt.Printf("%.2f\t", val)**
- выводит элемент с двумя знаками после запятой и табуляцией
---
**fmt.Println()**
- переход к новому тексту после вывода строк матрицы
**func addMatrices(a, b [][]float64) [][]float64 {**
- функция сложения матриц
---
**return elementWiseOperation(a, b, func(x, y float64) float64 { return x + y })**
- делегирование общей функции с операцией сложения
----
**func subtractMatrices(a, b [][]float64) [][]float64 {**
- функция вычитания матрица
---
**return elementWiseOperation(a, b, func(x, y float64) float64 { return x - y })**
- делегирование с операцией вычитания
---
**func elementWiseOperation(a, b [][]float64, op func(float64, float64) float64) [][]float64 {**
- универсальная функция поэлементной операции
---
**rows := len(a)**
- получение чисел строки
---
**cols := len(a[0])**
- получение числа столбцов
---
**result:= make([][]float64, rows)**
- создание новой матрицы для результата
---
**for i := 0; i < rows; i++ {**
- цикл по строкам
---
**result[i] = make([]float64, cols)**
- инициализация строки результата
---
**for j := 0; j < cols; j++ {**
- цикл по столбцам
---
**result[i][j] = op(a[i][j], b[i][j])**
- применение переданной операции к элементам
---
**func MultipleByScalar() {**
- функция умножения матрицы на скаляр
---
**matrix:= readMatrix("")**
- ввод матрицы без метки
---
**var scalar float64**
- объявление переменной для скаляра
---
**fmt.Print("Введите скаляр для умножения:")**
- приглашение к вводу чисел
---
**fmt.Scan(&scalar)**
- считывание скаляра
---
**result := make([][]float64, len(matrix))**
- создание результата
---
**for i := range matrix {**
- цикл по строкам
---
**result[i] = make([]float64, len(matrix[i]))**
- создание строки
---
**for j := range matrix[i] {**
- цикл по столбцам
---
**result[i][j] = matrix[i][j] * scalar**
- умножение элемента на скаляр
---
**fmt.Println("Результат умножения матрицы на скаляр: ")**
- заголовок результата
---
**printMatrix(result)**
- вывод результата
---
**func MultipleMatrices() {**
- функция умножения двух матриц
---
**a := readMatrix("A")**
- ввод первой матрицы
---
**b := readMatrix("B")**
- ввод второй матрицы
---
**if len(a[0]) != len(b) {**
- проверка совместимости размеров
---
**fmt.Println("Ошибка: количество столбцов матрицы A должно совпадать с количеством строк матрицы B")**
- вывод сообщения об ошибке
---
**return**
- после возврат 
---
**result := make([][]float64, len(a))**
- создание результата с числом строк как у A
---
**for i := range result {**
- цикл по строкам результата
---
**result[i] = make([]float64, len(b[0]))**
- создание строк с числом столбцов как у B
---
**for j := range result[i] {**
- цикл по столбцам результата
---
**for к := 0; к < len(b); k++ {**
- цикл по общей рекомендации
---
**result[i][j] += a[i][k] * b[k][j]**
- накопление произведений (стандартный алгоритм умножения)
---
**fmt.Println("Результат умножения матрицы:")**
- заголовок результата
---
**printMatrix(result)**
- вывод результата
---
**type matrixOperation func([][]float64, [][]float64) [][]float64**
- определение типа функции для операций над двумя матрицами
---
**func ExecuteMatrixOperation(op matrixOperation, OperationName строка) {**
- универсальная функция для сложений/вычитания
---
**fmt.Printf("Введите матрицы для операции %s\n", OperationName)**
- подсказка пользователю
---
**a := readMatrix("A")**
- ввод первой матрицы
---
**b := readMatrix("B")**
- ввод второй матрицы
---
**if len(a) != len(b) || len(a[0]) != len(b[0]) {**
- проверка одинаковой размерности
---
**fmt.Println("Ошибка: матрицы должны иметь одинаковую размерность")**
- сообщение об ошибке
---
**return**
- обратный выход при несовпадении
---
**result := op(a, b)**
- выполнение передаваемой операции
---
**fmt.Printf("Результат %s:\n", имя_операции)**
- результат операции
---
**printMatrix(result)**
- вывод результата
---


# Спасибо за внимание......
